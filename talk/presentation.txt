============================
 IronPython & Windows Forms
============================
-------------------
 A PyCon 2007 Talk
-------------------

.. include:: <s5defs.txt>
.. footer:: Michael Foord & Andrzej Krzywda 2007

.. contents:: IronPython & Winforms
   :class: handout


Introduction
============

.. class:: incremental

* Michael Foord (Fuzzyman)

.. class:: handout

    I have been programming with Python for nearly four years. I've written several `articles <http://www.voidspace.org.uk/python/articles.shtml>`_ on Python, and a couple of them are even worth reading. {sm;:-)}
    
    I am also the author of the following Python projects:

    * `rest2web <http://www.voidspace.org.uk/python/rest2web/>`_
    * `ConfigObj <http://www.voidspace.org.uk/python/configobj.html>`_
    * `Movable Python <http://www.voidspace.org.uk/python/rest2web/>`_
    
    I've written a tutorial on `IronPython and Windows Forms <http://www.voidspace.org.uk/ironpython/>`_. My blog is the `Voidspace Techie Blog <http://www.voidspace.org.uk/python/weblog/index.shtml>`_.
    
    I'm particularly grateful to IronPython. Because of it I'm now able to earn a living programming with Python, for Resolver Systems.
    
    I'm also writing a book, *IronPython in Action* for Manning publications. Expect to see it out early autumn time.

.. class:: incremental

* Andrzej Krzywda

.. class:: handout

    I'm an agile software developer. I appreciate the beauty and elegance of Python and Ruby, two great dynamic languages. I started programming in Ruby (on Rails) in 2004. Working with IronPython, for Resolver, was my first practical experience of working with Python. Before switching to Ruby/Python I was a Java developer.

.. class:: incremental

* Resolver Systems Ltd (London)

.. class:: handout

    `Resolver Systems <http://www.resolversystems.com>`_ is a small company (6 developers) based in London. Resolver Systems was created to develop a new business application. This has *just* gone out for a private beta test with our first customers and we should be going public with the details soon.
    
    Resolver the company started in late 2005. Andrzej joined Resolver in March 2006, Michael joined in April 2006.

.. class:: incremental

* Resolver the Application

.. class:: handout

    Resolver is a desktop application for businesses. .NET was initially chosen as the development platform, but a scripting language was needed as an integral part of the application. After discovering and trying IronPython (whilst it was still Beta) the two developers, as they then were, decided to write the whole application with IronPython.
    
    The Resolver codebase currently stands at over twenty thousand lines of production code and around seventy thousand lines of test code. About 1% of the production code is in C# and the rest IronPython.
    
    Resolver integrates Python in a very interesting way...

    
What is IronPython?
===================

.. class:: incremental

* IronPython is Python 2.4 (Some 2.5 features already there)

.. class:: handout

    Project started by Jim Hugunin who now heads a Microsoft team running the development.

    IronPython is a very faithful implementation of Python 2.4. All the core language features are there. 
    
    IronPython is *different* though. Python stack frames and bytecode are obviously not present, and so parts of the standard library that rely on these 'implementation details' don't work. Some examples: ``sys._settrace`` is missing (uses stack frames). Also ``inspect.get_argspec`` examines bytecode to fetch ``varargs`` and ``varkeywargs`` so it is broken, meaning that ``help`` doesn't work. 
    
    None of the C libraries work (obviously). Wrappers around .NET functionality have been created, for example for pyexpat, socket etc.
    
    A lot of third party libraries have problems as a result. The Microsoft team have put a lot of effort into fixing these problems where possible and the IronPython community (especially Seo and his Fepy project) have also provided a lot of patches to the standard library, ported projects across or created wrappers. With detective work most problems can be fixed, but you can't expect large frameworks or libraries to work without modification.

.. class:: incremental

* Written in C# for the .NET framework


.. class:: incremental

* Also runs on Mono

.. class:: handout

    In fact, the community edition (`Fepy <http://fepy.sourceforge.net>`_) is now *included* in Mono.
    
    Mono has partial support for Windows Forms. I think most/all of .NET 1.1 is there and some 2.0.


IronPython and .NET
===================

.. class:: incremental

* IronPython is a Python compiler

.. class:: handout

    The IronPython engine is actually an IronPython compiler. It compiles Python code into assemblies in memory. Although these assemblies can be saved to disk (making binary only distributions possible), because of the dynamic nature of Python they retain a dependency on the IronPython dlls.


.. class:: incremental

* So you use native .NET types

.. class:: handout

    IronPython has seamless integration with the .NET framework. Types can be passed back and forth from native .NET code with no conversion, making it very simple to use .NET classes from IronPython. This means that extending IronPython with C# (including accessing unmanaged code and the win32 APIs) is *much* easier than extending CPython with C.
    
    The exception is that attributes are missing and you can't consume IronPython assemblies from C#.  This is because (my understanding anyway) .NET doesn't garbage collect classes (rarely generated at runtime), so IronPython re-uses a single class under the hood. So you can't yet create classes that can be used from C#, which is part of the reason why you can't use .NET attributes.


Why Use IronPython?
===================

.. class:: handout

    If you don't need .NET you don't want IronPython. (Probably!) {sm;:-)} IronPython is at its best for .NET programmers.

    According to the `Computer Language Shootout <http://shootout.alioth.debian.org>`_ IronPython is generally a bit slower than CPython.

    For .NET programmers, Python is nicer than C#. It is also a ready made scripting language for embedding in applications.

* Use multi-core processors

.. class:: incremental

* Built-in security model with AppDomains

.. class:: incremental

* Native Windows GUI: Windows Forms

.. class:: incremental

* Access to third-party .NET components

.. class:: incremental

* Much easier to extend with C# than CPython and C

.. class:: incremental

* IronPython (on .NET) may be an easier corporate sell


.. class:: handout

    Third party components includes a huge range of sophisticated GUI components. Due to the Windows culture you usually have to pay for them! However we use a couple of big components in Resolver, and at least one of them (I'm pretty sure) wouldn't have an equivalent for any CPython GUI library.


Setting Up IronPython
=====================

.. class:: incremental

1) Install .NET 2.0 redistributable (`Horrible Microsoft URL <http://www.microsoft.com/downloads/details.aspx?familyid=0856eacb-4362-4b0d-8edd-aab15c5e04f5&displaylang=en>`_)

.. class:: handout

    Microsoft seem to be pushing out the .NET framework through Windows Update now (possibly as an optional update?). So many people are finding they don't need to do this. Good news for distributing IronPython applications.

.. class:: incremental

    2) Download IronPython {sm;:-o} (http://www.codeplex.com/IronPython)

.. class:: incremental

3) Setup the environment variable ``IRONPYTHONPATH`` pointing to the Python 2.4 standard library.

.. class:: handout

    This means you need Python 2.4 installed. The default location of the Python standard library will be ``C:\Python24\Lib``. You can just copy the Python standard library to another folder and add that location to ``IRONPYTHONPATH`` (or manually to ``sys.path``) and you can distribute the standard library with your applications.


Using .NET: Assemblies
======================


.. class:: incremental

* An assembly is a .NET library (usually a ``dll`` could be an ``exe``)

.. class:: handout

    Namespaces are the libraries contained within assemblies. You import from the namespaces after adding a reference to the assembly. Namespaces *usually* have the same name as the assembly, but not always.

.. class:: incremental

* The Windows Forms assembly is ``System.Windows.Forms``

.. class:: incremental

* In order to use the assembly you must add a reference to it

.. class:: incremental

* To do that we use the ``clr`` module, an IronPython built-in

.. class:: incremental

* ``clr.AddReference('System.Windows.Forms')``

.. class:: handout

    You can also load an assembly with a 'strong name', specifying the exact version you want:


    .. raw:: html

        {+coloring}    
        ref = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
        clr.AddReferenceByName(ref)
        {-coloring}
    
    Alternatively you can load an assembly object from a specific path, and then add a reference to that assembly object.

    .. raw:: html

        {+coloring}    
        from System.Reflection import Assembly
        assembly = Assembly.LoadFile(assemblyPath)
        clr.AddReference(assembly)
        {-coloring}
    

The Interactive Interpreter
===========================

.. class:: incremental

The IronPython interactive interpreter is ``ipy.exe``, which is also used to run scripts.

.. class:: handout

    This is the equivalent of ``python.exe``. 

    There is also ``ipyw.exe`` which is the equivalent of ``pythonw.exe`` and runs scripts without a console box.
    
    To switch on tab completion (very useful) and colour highlighting, run ``ipy.exe`` with the arguments:

        ``ipy -D -X:TabCompletion -X:ColorfulConsole``

.. image:: images/ip_console.jpg
    :width: 669
    :height: 302
    :align: center
    :alt: The IronPython Console
    :class: incremental
    

A Windows Forms Application
===========================

.. class:: incremental

* The most basic Windows Forms application uses the `Application Class <http://msdn2.microsoft.com/en-us/library/system.windows.forms.application.aspx>`_ and the `Form Class <http://msdn2.microsoft.com/en-us/library/system.windows.forms.form.aspx>`_

.. class:: incremental

* Application is responsible for starting the message loop.

.. class:: incremental

* You call the static method ``Run`` on the Application class.

.. class:: incremental

* This has three overloads. The one we're interested in takes a ``Form`` instance as the argument.

.. class:: handout

    Overloads based on type signature.  There are some advantages of statically typed languages!


Reading MSDN Docs
=================

.. class:: handout

    This example is fairly trivial, but once you can do this you can use any of the classes from the .NET framework from IronPython. A useful skill.

.. class:: incremental

* First browse to the `Form Class`_ page.

.. class:: incremental

* Scroll down to the bottom, follow the link to the `Form Members <http://msdn2.microsoft.com/en-us/library/system.windows.forms.form_members.aspx>`_ page.

.. class:: handout

    Every class has pages like these, plus pages for every public / private / protected member, including inherited members.

.. class:: incremental

* At the top of this page is the `Form constructor <http://msdn2.microsoft.com/en-us/library/system.windows.forms.form.form.aspx>`_.

.. class:: incremental

    Reading the C# example code shows us that the constructor is public (*phew*), and it takes no arguments.

        ``public Form()``


The Basic Example
=================

.. class:: incremental

Therefore, the *most trivial Windows Forms application possible* in IronPython:

.. class:: incremental

.. raw:: html
    
    {+coloring}
    import clr
    clr.AddReference('System.Windows.Forms')
    from System.Windows.Forms import Application, Form

    form = Form()
    Application.Run(form)
    {-coloring}

.. class:: handout

    This starts the message loop and makes the form visible, with all the default event handlers in place. The only one with any relevance for us is the one that handles the *Form Closing* event. This calls ``Application.Exit()``, disposes of the form and shuts down the message loop.


Setting Attributes
==================

.. class:: incremental small

.. raw:: html
    
    {+coloring}
    import clr
    clr.AddReference('System.Windows.Forms')
    from System.Windows.Forms import Application, Button, Form

    form = Form()
    form.Text = 'Hello World'
    {-coloring}

.. class:: incremental

* The ``Text`` property gets or sets a string

.. class:: incremental

* On a form this is the title

.. class:: incremental

* Requires a .NET string, but IronPython uses native types (hoorah)

.. class:: handout

    So no conversion is necessary.
    
    Most of the common properties are inherited from the ``Control`` class. So as you learn to configure controls it becomes easier.


Adding Controls
===============

.. class:: incremental small

.. raw:: html
    
    {+coloring}
    button = Button(Text='Click Me')
    form.Controls.Add(button)
    {-coloring}

.. class:: incremental

* Add a button to the parent control

.. class:: handout

    Note the alternative way of setting the ``Text``, through a keyword argument in the constructor. This can't be done with C# which doesn't have keyword arguments.

.. class:: incremental

* ``form.Controls`` is a collection class, with various methods.

.. class:: handout

    And they are enumerable.
    
    Instead of using ``Controls.Add`` we *could* have done ``button.Parent = form``, which would have added the button to the form's controls collection for us.
    
.. class:: incremental

* The order you add controls is relevant: the Z-Order

.. class:: handout

    The Z-order is named because it is the 'Z-axis'. Controls you add *first* are higher in the Z-order and so if they overlap you will saee the one you added first. This is more of a problem if you layout your GUI using absolute positions.
    
    You can use methods on the ``ControlCollection`` (the collections property) to reorder the controls, or call the ``BringToFront`` method.

   
Event Handlers
==============

.. class:: incremental small

* Create an event handler function and add it to an event

.. class:: incremental small

.. raw:: html
    
    {+coloring}
    clr.AddReference('System.Drawing')
    from System.Drawing import Point
    x = y = 0
    def onClick(sender, event):
       global x, y
       x += 15
       y += 15
       button.Location = Point(x, y)
    
    button.Click += onClick
    {-coloring}

.. class:: handout

    ``onClick`` is an event handler function (a delegate in C#). We and add it to the event using 'add in place'. Note that we can remove it using '-='. It is IronPython 'under the hood' which converts our function into a delegate.
    
    The arguments that Windows Forms event handlers receive are ``sender`` and ``event``. The sender is the control on which the event happened, the event will be an instance of one of the ``EventArgs`` classes, and may contain useful information about the event (state of the mouse buttons, location of the mouse etc). You may also be able to cancel the event.

.. class:: incremental small

.. raw:: html
    
    {+coloring}
    Application.Run(form)
    {-coloring}


.. image:: images/simple_form.jpg
    :width: 300
    :height: 300
    :align: center
    :alt: Our Example Form with Button
    :class: handout


Subclassing Controls
====================

.. class:: incremental small

* It's not normal to pass a form direct to ``Application.Run``

.. class:: incremental small

* More usual to do GUI initialisation in a subclass of ``Form``


.. class:: incremental small

.. raw:: html
    
    {+coloring}
    class MainForm(Form):
        def __init__(self):
            Form.__init__(self)
            self.Text = "Hello World"
    
    form = MainForm()
    Application.Run(form)
    {-coloring}

.. class:: handout

.. note::

    For example if you want to make a `Panel <http://msdn2.microsoft.com/en-us/library/system.windows.forms.panel_members.aspx>`_ selectable you need to call
    ``panel.SetStyle(ControlStyles.Selectable, True)``. This is a protected method and
    can only be called from a subclass.


The Multi-Tabbed Image Viewer
=============================

.. class:: incremental

* This is our sample Windows Forms Application

.. class:: incremental

* Available for download from `code.google.com/p/tabbedimages/ <http://code.google.com/p/tabbedimages/>`_

.. class:: incremental

* Illustrates more advanced aspects of Windows Forms


Initialising with a TabControl
==============================

.. class:: incremental

* ``TabControl`` is the container for ``TabPages``


.. class:: incremental small

.. raw:: html
    
    {+coloring}
    def initTabControl(self):
        self.tabControl = TabControl(
            Dock = DockStyle.Fill,
            Alignment = TabAlignment.Bottom
        )
        self.Controls.Add(self.tabControl)
    {-coloring}

.. class:: handout

    Here we use keyword arguments in the constructor to set the properties.
    
    We initialise the ``TabControl`` in its own method.
    
    ``self`` is a sub-class of ``Form``; hence ``self.Controls.Add(self.tabControl)``.


.. class:: incremental small

* ``Dock = DockStyle.Fill`` is for layout

.. class:: handout

    It tells the parent control how to layout this control. `DockStyle <http://msdn2.microsoft.com/en-us/library/system.windows.forms.dockstyle.aspx>`_ is an enumeration and ``DockStyle.Fill`` means fill all the available space. Alternatives are ``Top``, ``Bottom``, ``Left``, ``Right`` and ``None`` (the default).
    
    An alternative way to layout controls is to use the ``Anchor`` property.  This is generally less useful.
    
    If you have several controls which use ``DockStyle.Top`` then they will be stacked horizontally - for some reason in the opposite order to which they are added: the last one going to the top of the parent, the one before last underneath the last one and so on. Can be very useful. In our application we first add the Tabcontrol (``DockStyle.Fill``) followed by the ToolStrip (``DockStyle.Top`` - this appears in the middle), last of all the MenuStrip (``DockStyle.Top``) which appears at the top.

.. class:: incremental small

* ``Alignment = TabAlignment.Bottom`` determines where the tabs are placed


Creating New TabPages
=====================

.. class:: incremental small

.. raw:: html
    
    {+coloring}
    def createTab(self, image, label):        
        tabPage = TabPage()
        self.tabControl.TabPages.Add(tabPage)
        self.tabControl.SelectedTab = tabPage
        tabPage.Text = label
        pictureBox = self.getPictureBox(image)
        tabPage.Controls.Add(pictureBox)   
    {-coloring}

.. class:: handout

    All the names here are from the ``System.Windows.Forms`` namespace.


.. class:: incremental

* New tab pages must be added to the ``TabControl.TabPages`` collection

.. class:: incremental

* Each TabPage is a container, to which we can add controls


Open File Dialog
================

.. class:: incremental small

.. raw:: html
    
    {+coloring} 
    filter = "Images (*.BMP;*.JPG;*.GIF)|*.BMP;*.JPG;*.GIF|All files (*.*)|*.*"
    def onOpen(self, _, __):
        openFileDialog = OpenFileDialog(
            Filter = filter,
            Multiselect = True
        )
        if openFileDialog.ShowDialog() == DialogResult.OK:                
            for fileName in openFileDialog.FileNames:
                ...
    {-coloring}

.. class:: handout

    This method is an event handler. The two unused arguments in the method signature are ``sender`` and ``event``.

.. class:: incremental

* Standard Windows open file dialog

.. class:: incremental

* Call ``ShowDialog`` on any form (or dialog) to open it modally


Other Topics
============

* File dialog.
* System message box.
* Context menu and ordinary menu.
* Clipboard.
* Bitmap

* Screenshots from Mono



Further
=======

Creating dialogs in Visual Studio Express Designer (C#), subclassing in IronPython
Creating C# classes and using from IronPython
Custom executable (most basic form of embedding)


Questions
=========

Any questions?

