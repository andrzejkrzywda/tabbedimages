============================
 IronPython & Windows Forms
============================
-------------------
 A PyCon 2007 Talk
-------------------

.. include:: <s5defs.txt>
.. footer:: Michael Foord & Andrzej Krzywda 2007

.. contents:: IronPython & Winforms
   :class: handout


Introduction
============

.. class:: incremental

* Michael Foord (Fuzzyman)

.. class:: handout

    I have been programming with Python for nearly four years. I've written several `articles <http://www.voidspace.org.uk/python/articles.shtml>`_ on Python, and a couple of them are even worth reading. {sm;:-)}
    
    I am also the author of the following Python projects:

    * `rest2web <http://www.voidspace.org.uk/python/rest2web/>`_
    * `ConfigObj <http://www.voidspace.org.uk/python/configobj.html>`_
    * `Movable Python <http://www.voidspace.org.uk/python/rest2web/>`_
    
    I've written a tutorial on `IronPython and Windows Forms <http://www.voidspace.org.uk/ironpython/>`_. My blog is the `Voidspace Techie Blog <http://www.voidspace.org.uk/python/weblog/index.shtml>`_.
    
    I'm particularly grateful to IronPython. Because of it I'm now able to earn a living programming with Python, for Resolver Systems.
    
    I'm also writing a book, *IronPython in Action* for Manning publications. Expect to see it out early autumn time.

.. class:: incremental

* Andrzej Krzywda

.. class:: handout

    I'm an agile software developer. I appreciate the beauty and elegance of Python and Ruby, two great dynamic languages. I started programming in Ruby (on Rails) in 2004. Working with IronPython, for Resolver, was my first practical experience of working with Python. Before switching to Ruby/Python I was a Java developer.

.. class:: incremental

* Resolver Systems Ltd (London)

.. class:: handout

    `Resolver Systems <http://www.resolversystems.com>`_ is a small company (6 developers) based in London. Resolver Systems was created to develop a new business application. This has *just* gone out for a private beta test with our first customers and we should be going public with the details soon.
    
    Resolver the company started in late 2005. Andrzej joined Resolver in March 2006, Michael joined in April 2006.

.. class:: incremental

* Resolver the Application

.. class:: handout

    Resolver is a desktop application for businesses. .NET was initially chosen as the development platform, but a scripting language was needed as an integral part of the application. After discovering and trying IronPython (whilst it was still Beta) the two developers, as they then were, decided to write the whole application with IronPython.
    
    The Resolver codebase currently stands at over twenty thousand lines of production code and around seventy thousand lines of test code. About 1% of the production code is in C# and the rest IronPython.
    
    Resolver integrates Python in a very interesting way...

    
What is IronPython?
===================

.. class:: incremental

* IronPython is Python 2.4 (Some 2.5 features already there)

.. class:: handout

    Project started by Jim Hugunin who now heads a Microsoft team running the development.

    IronPython is a very faithful implementation of Python 2.4. All the core language features are there. 
    
    IronPython is *different* though. Python stack frames and bytecode are obviously not present, and so parts of the standard library that rely on these 'implementation details' don't work. Some examples: ``sys._settrace`` is missing (uses stack frames). Also ``inspect.get_argspec`` examines bytecode to fetch ``varargs`` and ``varkeywargs`` so it is broken, meaning that ``help`` doesn't work. 
    
    None of the C libraries work (obviously). Wrappers around .NET functionality have been created, for example for pyexpat, socket etc.
    
    A lot of third party libraries have problems as a result. The Microsoft team have put a lot of effort into fixing these problems where possible and the IronPython community (especially Seo and his Fepy project) have also provided a lot of patches to the standard library, ported projects across or created wrappers. With detective work most problems can be fixed, but you can't expect large frameworks or libraries to work without modification.

.. class:: incremental

* Written in C# for the .NET framework


.. class:: incremental

* Also runs on Mono

.. class:: handout

    In fact, the community edition (`Fepy <http://fepy.sourceforge.net>`_) is now *included* in Mono.
    
    Mono has partial support for Windows Forms. I think most/all of .NET 1.1 is there and some 2.0.


IronPython and .NET
===================

.. class:: incremental

* IronPython is a Python compiler

.. class:: handout

    The IronPython engine is actually an IronPython compiler. It compiles Python code into assemblies in memory. Although these assemblies can be saved to disk (making binary only distributions possible), because of the dynamic nature of Python they retain a dependency on the IronPython dlls.


.. class:: incremental

* So you use native .NET types

.. class:: handout

    IronPython has seamless integration with the .NET framework. Types can be passed back and forth from native .NET code with no conversion, making it very simple to use .NET classes from IronPython. This means that extending IronPython with C# (including accessing unmanaged code and the win32 APIs) is *much* easier than extending CPython with C.
    
    The exception is that attributes are missing and you can't consume IronPython assemblies from C#.  This is because (my understanding anyway) .NET doesn't garbage collect classes (rarely generated at runtime), so IronPython re-uses a single class under the hood. So you can't yet create classes that can be used from C#, which is part of the reason why you can't use .NET attributes.


Why Use IronPython?
===================

.. class:: handout

    If you don't need .NET you don't want IronPython. (Probably!) {sm;:-)} IronPython is at its best for .NET programmers.

    According to the `Computer Language Shootout <http://shootout.alioth.debian.org>`_ IronPython is generally a bit slower than CPython.

    For .NET programmers, Python is nicer than C#. It is also a ready made scripting language for embedding in applications.

* Use multi-core processors

.. class:: incremental

* Built-in security model with AppDomains

.. class:: incremental

* Native Windows GUI: Windows Forms

.. class:: incremental

* Access to third-party .NET components

.. class:: incremental

* Much easier to extend with C# than CPython and C

.. class:: incremental

* IronPython (on .NET) may be an easier corporate sell


.. class:: handout

    Third party components includes a huge range of sophisticated GUI components. Due to the Windows culture you usually have to pay for them! However we use a couple of big components in Resolver, and at least one of them (I'm pretty sure) wouldn't have an equivalent for any CPython GUI library.


Setting Up IronPython
=====================

.. class:: incremental

1) Install .NET 2.0 redistributable (`Horrible Microsoft URL <http://www.microsoft.com/downloads/details.aspx?familyid=0856eacb-4362-4b0d-8edd-aab15c5e04f5&displaylang=en>`_)

.. class:: handout

    Microsoft seem to be pushing out the .NET framework through Windows Update now (possibly as an optional update?). So many people are finding they don't need to do this. Good news for distributing IronPython applications.

.. class:: incremental

    2) Download IronPython {sm;:-o} (http://www.codeplex.com/IronPython)

.. class:: incremental

3) Setup the environment variable ``IRONPYTHONPATH`` pointing to the Python 2.4 standard library.

.. class:: handout

    This means you need Python 2.4 installed. The default location of the Python standard library will be ``C:\Python24\Lib``. You can just copy the Python standard library to another folder and add that location to ``IRONPYTHONPATH`` (or manually to ``sys.path``) and you can distribute the standard library with your applications.


Using .NET: Assemblies
======================


.. class:: incremental

* An assembly is a .NET library (usually a ``dll`` could be an ``exe``)

.. class:: handout

    Difference between assemblies and namespaces XXX.

.. class:: incremental

* The Windows Forms assembly is ``System.Windows.Forms``

.. class:: incremental

* In order to use the assembly you must add a reference to it

.. class:: incremental

* To do that we use the ``clr`` module, an IronPython built-in

.. class:: handout

    Other uses of clr module XXXX.

.. class:: incremental

* ``clr.AddReference('System.Windows.Forms')``
    

The Interactive Interpreter
===========================

.. class:: incremental

The IronPython interactive interpreter is ``ipy.exe``, which is also used to run scripts.

.. class:: handout

    This is the equivalent of ``python.exe``. 

    There is also ``ipyw.exe`` which is the equivalent of ``pythonw.exe`` and runs scripts without a console box.
    
    To switch on tab completion (very useful) and colour highlighting, run ``ipy.exe`` with the arguments:

        ``ipy -D -X:TabCompletion -X:ColorfulConsole``

.. image:: images/ip_console.jpg
    :width: 669
    :height: 302
    :align: center
    :alt: The IronPython Console
    :class: incremental
    

A Windows Forms Application
===========================

.. class:: incremental

* The most basic Windows Forms application uses the `Application Class <http://msdn2.microsoft.com/en-us/library/system.windows.forms.application.aspx>`_ and the `Form Class <http://msdn2.microsoft.com/en-us/library/system.windows.forms.form.aspx>`_

.. class:: incremental

* Application is responsible for starting the message loop.

.. class:: incremental

* You call the static method ``Run`` on the Application class.

.. class:: incremental

* This has three overloads. The one we're interested in takes a ``Form`` instance as the argument.

.. class:: handout

    Overloads based on type signature.  There are some advantages of statically typed languages!


Reading MSDN Docs
=================

.. class:: handout

    This example is fairly trivial, but once you can do this you can use any of the classes from the .NET framework from IronPython. A useful skill.

.. class:: incremental

* First browse to the `Form Class`_ page.

.. class:: incremental

* Scroll down to the bottom, follow the link to the `Form Members <http://msdn2.microsoft.com/en-us/library/system.windows.forms.form_members.aspx>`_ page.

.. class:: handout

    Every class has pages like these, plus pages for every public / private / protected member, including inherited members.

.. class:: incremental

* At the top of this page is the `Form constructor <http://msdn2.microsoft.com/en-us/library/system.windows.forms.form.form.aspx>`_.

.. class:: incremental

    Reading the C# example code shows us that the constructor is public (*phew*), and it takes no arguments.

        ``public Form()``


The Basic Example
=================

.. class:: incremental

Therefore, the *most trivial Windows Forms application possible* in IronPython:

.. class:: incremental

.. raw:: html
    
    {+coloring}
    import clr
    clr.AddReference('System.Windows.Forms')
    from System.Windows.Forms import Application, Form

    form = Form()
    Application.Run(form)
    {-coloring}

.. class:: handout

    This starts the message loop and makes the form visible, with all the default event handlers in place. The only one with any relevance for us is the one that handles the *Form Closing* event. This calls ``Application.Exit()``, disposes of the form and shuts down the message loop.

Next
====

::

    form.Text = 'Hello World'

Text property gets or sets a string. We can set it directly from IronPython with an IronPython string. ::

    button = Button(Text='Click Me')

Proeprties can also be setup in the constructor using keyword arguments (which can't be done from C#).

    form.Controls.Add(button)
    form.Show()

Add the button to the forms controls (a C# container).
Show the form - form untresponsive because the application loop is not yet started. ::

    from System.Drawing import Point
    x = y = 0
    def click(sender, event):
       global x, y
       print 'clicked'
       x += 15
       y += 15
       button.Location = Point(x, y)
    
    button.Click += click

Define an event handler function (a delegate in C#) and add it to the event using 'add in place'. Note that we can unregister it using '-='.


Demo Application
================

Multi-tabbed image viewer.

DockStyle
File dialog.
System message box.
Context menu and ordinary menu.
Clipboard.
Tab pages

Bitmap

Screenshots from Mono

Structure

View-Controllers (minimal model)
Command pattern


Further
=======

Creating dialogs in Visual Studio Express Designer (C#), subclassing in IronPython
Creating C# classes and using from IronPython
Custom executable (most basic form of embedding)


Questions
=========

Any questions?

